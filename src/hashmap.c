#include "hashmap.h"
/**
 * before using hashmap, something critical should be declared firstly
 * key and value are references to original data, it is not copy version, meaning that free original(key, data) will make hashmap not work properly.
 * DO NOT FREE key and data
 **/

void add_item_list(const char* key, struct list_head* phead){
    struct list_item * item = (struct list_item*)malloc(sizeof(struct list_item));
    strcpy(item->keys, key);
    LIST_INSERT_HEAD(&phead->head,item,pointers);
}

void delete_item_list(const char* key, struct list_head* phead){
    if(!LIST_EMPTY(&phead->head)){
        struct list_item* pitem;
        LIST_FOREACH(pitem, &phead->head, pointers){
            if(strcmp(pitem->keys, key) == 0 ){
                LIST_REMOVE(pitem,pointers);
                free(pitem);
            }
        }
    }
}

bool find_item_list(const char* key, struct list_head* phead){
    if(!LIST_EMPTY(&phead->head)){
        struct list_item* pitem;
        LIST_FOREACH(pitem, &phead->head, pointers){
            if(strcmp(pitem->keys, key) == 0){
                return true;
            }else{
                continue;
            }
        }
    }
    return false;
}

void clear_item_list(struct list_head* phead){
    while(!LIST_EMPTY(&phead->head)){
        struct list_item* pitem = LIST_FIRST(&phead->head);
        LIST_REMOVE(pitem, pointers);
        free(pitem);
    }
}

bool is_empty_list(struct list_head* phead){
    if(phead == NULL){
        return true;
    }
    return LIST_EMPTY(&phead->head);
}

hmap_t* create_hmap(size_t h_max_size){
    hmap_t* pmap = (hmap_t*)malloc(sizeof(hmap_t));
    pmap->h_max_size = h_max_size;
    memset(&pmap->h_map,0,sizeof(pmap->h_map));
    hcreate_r(h_max_size,&pmap->h_map);
    LIST_INIT(&pmap->head.head);
    return pmap;
}

void destroy_hmap(hmap_t* pmap){
    hdestroy_r(&pmap->h_map);
    clear_item_list(&pmap->head);
    free(pmap);
    pmap = NULL;
}

int add_item_hmap(hmap_t* pmap, char* key, void* data){
    unsigned n = 0;
    ENTRY e, *ep;
    e.key = key;
    e.data = data;
    n = hsearch_r(e, ENTER, &ep, &pmap->h_map);
    if(n){
        add_item_list(key,&pmap->head);
    }
    return n;
}

int add_update_item_hmap(hmap_t* pmap, char* key, void* data){
    unsigned n = 0;
    if(pmap){
        ENTRY e, *ep;
        e.key = key;
        e.data = data;
        if(!find_item_list(key, &pmap->head)){
            add_item_list(key, &pmap->head);
        }
        n = hsearch_r(e, ENTER, &ep, &pmap->h_map);
        if(n){
            ep->data = e.data;
        }
    }
    return n;
}

void* get_item_hmap(hmap_t* pmap, char* key){
    if(!pmap){
      return NULL;
    }
    ENTRY e, *ep;
    e.key = key;
    if(hsearch_r(e, FIND, &ep, &pmap->h_map)){
        return ep->data;
    }else{
        return NULL;
    }
}

void delete_item_hmap(hmap_t* pmap, char* key){
  if(pmap){
    ENTRY e, *ep;
    e.key = key;
    unsigned n = 0;
    n = hsearch_r(e, ENTER, &ep, &pmap->h_map);
    if(n){
        ep->data = (void*)NULL;
        delete_item_list(key, &pmap->head);
    }
  }
}

bool contain_item_hmap(hmap_t* pmap, char* key){
    if(!pmap){
      return false;
    }
    ENTRY e, *ep;
    e.key = key;
    if(hsearch_r(e,FIND,&ep,&pmap->h_map)){
        if(find_item_list(key, &pmap->head)){
            return true;
        }else{
            return false;
        }
    }else{
        return false;
    }
}

bool is_empty_hmap(hmap_t* pmap){
    if(pmap == NULL || &pmap->head == NULL){
        return true;
    }
    return is_empty_list(&pmap->head);
}

/**
int main(void)
{
    char key[64] = "lever1";
    char data[64] = "data";

    hmap_t* pmap = create_hmap(64);
    add_item_hmap(pmap, key, (void*)data);
    printf("key: %s => value: %s\n",key,(char*)get_item_hmap(pmap, key));
    char data2[64] = "data64";
    add_update_item_hmap(pmap, key, (void*)data2);
    printf("key: %s => value: %s\n",key,(char*)get_item_hmap(pmap, key));
    delete_item_hmap(pmap, key);
    printf("key: %s => value: %s\n",key,(char*)get_item_hmap(pmap, key));
    return 0;
}
**/
